(**************************************************************************)
(*                                                                        *)
(*  VOCaL -- A Verified OCaml Library                                     *)
(*                                                                        *)
(*  Copyright (c) 2018 The VOCaL Project                                  *)
(*                                                                        *)
(*  This software is free software, distributed under the MIT license     *)
(*  (as described in file LICENSE enclosed).                              *)
(**************************************************************************)

(* Authors:
     Mário Pereira (LRI, Univ Paris-Saclay then
                    NOVA-LINCS, Universidade Nova de Lisboa)
     Jean-Christophe Filliâtre (CNRS, LRI, Univ Paris-Saclay) *)

(* Mutable queue implementation, following OCaml's queue implementation *)

module Impl

  use int.Int
  use ref.Ref
  use map.Map
  use map.Const
  use SinglyLL_impl.Mem
  use option.Option
  use seq.Seq
  use import seq.Mem as T
  use import seq.Distinct as D

  type t 'a = {
    mutable ghost length   : int;
    mutable       first    : loc 'a;
    mutable       last     : loc 'a;
    mutable ghost view     : seq 'a;
    mutable ghost list     : seq (loc 'a);
    mutable ghost used_mem : mem 'a
  } invariant { length > 0 -> first = list[0] /\ last = list[length - 1] /\ 
                           used_mem.next last = Some null }
    invariant { length = 0 -> first = last = null }
    invariant { length = Seq.length view = Seq.length list }
    invariant { forall i. 0 <= i < length -> list[i] <> null }
    invariant { D.distinct list }
    invariant { forall x: loc 'a. T.mem x list <-> used_mem.next x <> None }
    invariant { forall i. 0 <= i < length - 1 ->
                  used_mem.next list[i] = Some list[i+1] }
    invariant { forall i. 0 <= i < length ->
                  used_mem.contents list[i] = Some view[i] }
    by {
      length = 0; first = null; last = null;
      view = empty; list = empty; used_mem = empty_memory ();
    }

  (* OCaml code starts here *)

  exception Empty

  lemma mem_tail: forall x: 'a, s: seq 'a.
    Seq.length s > 0 ->
    mem x s <-> (x = s[0] \/ mem x s[1 .. ])

  let create () : t 'a
    ensures { result.view = empty }
    ensures { result.used_mem = empty_memory () }
  = { length = 0; first = null; last = null;
      view = empty; list = empty; used_mem = empty_memory () }

  let is_empty (q: t 'a) : bool
    ensures { result <-> q.view == empty }
  = q.first == null

  let add (x: 'a) (q: t 'a) : unit
    ensures { q.view == snoc (old q.view) x }
  = let c = mk_cell q.used_mem x null in
    if q.last == null then begin
      q.first <- c;
      q.last  <- c;
      q.length <- 1;
      q.view <- cons x Seq.empty;
      q.list <- cons c Seq.empty
    end else begin
      set_next q.used_mem q.last c;
      q.last <- c;
      q.length <- q.length + 1;
      q.view <- snoc q.view x;
      q.list <- snoc q.list c;
    end

  let push = add

  let take_opt (q: t 'a) : option 'a
    ensures  { old q.view == empty -> result = None }
    ensures  { not (old q.view == empty) -> result = Some (old q.view)[0] }
    ensures  { old q.view == empty -> q.view == old q.view }
    ensures  { not old q.view == empty -> q.view == (old q.view)[1 .. ] }
  =
  if is_empty q then None
  else
  let x = get_content q.used_mem q.first in
    if get_next q.used_mem q.first == null then begin
      free q.used_mem q.first;
      q.first <- null;
      q.last <- null;
      q.length <- 0;
      q.view <- Seq.empty;
      q.list <- Seq.empty
    end else begin
      let ghost oldfirst = q.first in
      q.first <- get_next q.used_mem q.first;
      q.length <- q.length - 1;
      q.view  <- q.view[1 .. ];
      q.list  <- q.list[1 .. ];
      free q.used_mem oldfirst
    end;
    Some x

  let take (q: t 'a) : 'a
    raises   { Empty -> (old q.view) == empty }
    ensures  { q.view == (old q.view)[1 .. ] }
    ensures  { result = (old q.view)[0] }
    ensures  { old q.view == cons result q.view }
  =
  match take_opt q with
  | None -> raise Empty
  | Some e -> e
  end
  
  let pop = take

  let peek (q: t 'a) : 'a
    raises   { Empty -> q.view == empty }
    ensures  { result = q.view[0] }
  = 
  if is_empty q then raise Empty;
  get_content q.used_mem q.first

  let top = peek
  
  let peek_opt (q: t 'a) : option 'a
    ensures  { old q.view == empty -> result = None }
    ensures  { not (old q.view == empty) -> result = Some q.view[0] }
  = 
  if is_empty q then None else Some (get_content q.used_mem q.first)
  
  let clear (q: t 'a) : unit 
    ensures { q.view == empty }
  =
  q.length <- 0; 
  q.first <- null; 
  q.last <- null;
  q.view <- empty; 
  q.list <- empty; 
  q.used_mem <- empty_memory ()

  predicate disjoint_queue (q1 q2: t 'a) =
    disjoint_mem q1.used_mem q2.used_mem

  (* lemma aux: forall q1 q2: t 'a. *)
  (*   disjoint_queue q1 q2 -> forall i. 0 <= i < Seq.length q1.list -> *)
  (*   not (mem q1.list[i] q2.list) *)

  let transfer (q1 q2: t 'a) : unit
    requires { disjoint_mem q1.used_mem q2.used_mem }
    ensures  { q2.view == (old q2.view) ++ (old q1.view) }
    ensures  { q1.view == empty }
  = let lemma disjoint_mem_disjoint_list (q1 q2: t 'a)
      requires { disjoint_queue q1 q2 }
      ensures  { forall i. 0 <= i < Seq.length q1.list ->
                   not (mem q1.list[i] q2.list) }
    = () in
    if not (is_empty q1) then
      if is_empty q2 then begin
        q2.length, q1.length <- q1.length, 0;
        q2.first, q2.last <- q1.first, q1.last;
        q2.list <- q2.list ++ q1.list;
        q2.view <- q2.view ++ q1.view;
        q2.used_mem, q1.used_mem <- q1.used_mem, empty_memory ();
        (* clear q1 is inlined, since type invariant for q1 is now broken *)
        q1.first, q1.last, q1.list, q1.view <- null, null, Seq.empty, Seq.empty;
      end else begin
        q2.length <- q2.length + q1.length;
        q1.length <- 0;
        set_next q2.used_mem q2.last q1.first;
        q2.last <- q1.last;
        q2.list <- q2.list ++ q1.list;
        q2.view <- q2.view ++ q1.view;
        q2.used_mem <- mem_union q1.used_mem q2.used_mem;
        q1.used_mem <- empty_memory ();
        (* clear q1 is inlined, since type invariant for q1 is now broken *)
        q1.first, q1.last, q1.list, q1.view <- null, null, Seq.empty, Seq.empty
      end

end

module Correct

  use Impl

  clone Queue.Sig with
    type t, predicate disjoint_t = disjoint_queue,
    val  create, val add, val push, val take, val take_opt, val pop, 
    val peek, val peek_opt, val top, val is_empty,  
    val clear, val transfer

end
